0) Project shape and tech choices

Monorepo in one Replit project with two workspaces:

apps/client React + Vite + TypeScript

apps/server Node + Express + TypeScript

Database: SQLite via Prisma ORM. File at apps/server/prisma/dev.sqlite

API style: REST JSON under /api/*

State on client: React Query for server state. Local component state for forms.

Styling: minimal CSS modules. No heavy UI kit for v0.1.

Agent: one service on the server that calls an LLM with a short prompt template. Environment variable for the API key and model.

1) Top-level files and scripts

Create at repository root:

package.json that uses pnpm workspaces and scripts to run both client and server

.env.example with OPENAI_API_KEY=, OPENAI_MODEL=gpt-4o-mini, PORT=5050

.gitignore for node, dist, sqlite, env files

README.md with quickstart

Example package.json:

{
  "name": "balance-agent",
  "private": true,
  "workspaces": ["apps/*"],
  "scripts": {
    "dev": "pnpm -r run dev",
    "build": "pnpm -r run build",
    "start": "pnpm -r run start",
    "format": "pnpm -r run format",
    "lint": "pnpm -r run lint"
  },
  "devDependencies": {
    "concurrently": "8.2.2",
    "prettier": "3.2.5"
  }
}

2) Server setup apps/server

Create files:

apps/server/package.json

apps/server/src/index.ts

apps/server/src/routes/*

apps/server/src/services/*

apps/server/src/lib/*

apps/server/prisma/schema.prisma

apps/server/.env will be copied from root when running on Replit

apps/server/package.json:

{
  "name": "balance-agent-server",
  "type": "module",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/index.js",
    "prisma:gen": "prisma generate",
    "prisma:migrate": "prisma migrate dev --name init",
    "prisma:seed": "tsx prisma/seed.ts"
  },
  "dependencies": {
    "cors": "2.8.5",
    "dotenv": "16.4.5",
    "express": "4.19.2",
    "openai": "4.55.0",
    "zod": "3.23.8",
    "@prisma/client": "5.16.1"
  },
  "devDependencies": {
    "tsx": "4.7.1",
    "prisma": "5.16.1",
    "typescript": "5.4.5"
  }
}


apps/server/tsconfig.json:

{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "outDir": "dist",
    "rootDir": "src",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  },
  "include": ["src", "prisma"]
}

2a) Prisma schema apps/server/prisma/schema.prisma

Models are minimal and cover all 4 features and gamification.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:dev.sqlite"
}

enum EntryType {
  JOURNAL
  GRATITUDE
  CHECKIN
}

model User {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  displayName   String?
  settings      Settings?
  entries       Entry[]
  checkins      Checkin[]
  badges        Badge[]
  weeklyReports WeeklyReport[]
}

model Settings {
  id                String  @id @default(cuid())
  userId            String  @unique
  user              User    @relation(fields: [userId], references: [id])
  promptStyle       String? // "gentle", "direct"
  morningWindow     String? // "07:00-09:00"
  eveningWindow     String? // "20:00-22:00"
}

model Entry {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  type      EntryType
  content   String   // free text for JOURNAL or GRATITUDE, JSON string for CHECKIN summary if needed
  meta      Json?
  createdAt DateTime @default(now())
}

model Checkin {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  energy      Int      // 0-10
  rest        Int      // 0-10
  focus       Int      // 0-10
  connection  Int      // 0-10
  note        String?
  createdAt   DateTime @default(now())
}

model Badge {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  code      String   // "FIRST_ENTRY", "WEEK_STREAK_7", "GRATITUDE_30"
  grantedAt DateTime @default(now())
}

model WeeklyReport {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  weekStart DateTime
  text      String
  createdAt DateTime @default(now())
}


Add a simple seed at apps/server/prisma/seed.ts that creates a demo user and a couple of practices.

2b) Server entry apps/server/src/index.ts

Express app with CORS enabled for client origin

JSON body parser

Health route /api/health

Mount routes: /api/entries, /api/checkins, /api/summary, /api/agent, /api/gamification

2c) Validation and helpers

src/lib/prisma.ts export PrismaClient singleton

src/lib/scoring.ts function to compute a BalanceScore from checkin sliders using a simple weighted average, and streak utilities

src/services/agent.ts LLM call. It takes recent context and returns a small JSON card

Agent system prompt for src/services/agent.ts:

You are a gentle life-balance coach. Speak concisely. Return JSON with keys:
- prompt: a short journaling or gratitude prompt tailored to the moment
- reflection: one compassionate sentence that mirrors the user's current state
- practice: a tiny actionable practice that takes 1 to 3 minutes
- category: one of ["journal","gratitude","reset","wind_down"]
Keep outputs short and practical. Avoid therapy claims. No medical advice.


Agent function should accept:

type AgentContext = {
  timeOfDay: "morning" | "midday" | "evening";
  lastMood?: number; // 0-10
  lastGratitude?: string;
  lastEntrySnippet?: string;
};


It returns:

type AgentCard = {
  prompt: string;
  reflection: string;
  practice: string;
  category: "journal" | "gratitude" | "reset" | "wind_down";
};


Use env OPENAI_API_KEY and OPENAI_MODEL. If missing, return a deterministic offline fallback card.

2d) Routes and contracts

Implement routes with Zod validation.

POST /api/entries

Body: { type: "JOURNAL" | "GRATITUDE", content: string, meta?: any }

Creates an Entry for the demo user.

Returns the created object.

GET /api/entries

Query: type optional, limit optional

Returns recent entries by type.

POST /api/checkins

Body: { energy: number, rest: number, focus: number, connection: number, note?: string }

Creates Checkin and stores a mirrored Entry with type CHECKIN and a computed BalanceScore in meta.

GET /api/summary/weekly

Returns the last 7 days totals: number of journal entries, gratitude entries, average BalanceScore, current streak length, and any badges earned this week.

POST /api/agent/card

Body: { timeOfDay, lastMood?, lastGratitude?, lastEntrySnippet? }

Returns an AgentCard as defined.

GET /api/gamification

Returns { streakDays: number, badges: Badge[] }

2e) Gamification rules in src/lib/scoring.ts

Streak: number of consecutive days with at least one entry of any type

Badges:

FIRST_ENTRY when first ever Entry is created

WEEK_STREAK_7 when streakDays >= 7

GRATITUDE_30 when total GRATITUDE entries >= 30

BalanceScore formula for a checkin: score = round((energy + rest + focus + connection) / 4)

Grant badges automatically in create handlers.

3) Client setup apps/client

Create files:

apps/client/package.json

apps/client/vite.config.ts

apps/client/tsconfig.json

apps/client/src/main.tsx

apps/client/src/App.tsx

apps/client/src/api/client.ts Axios instance with baseURL from env

apps/client/src/hooks/useApi.ts simple wrappers using React Query

apps/client/src/components/* reusable UI

apps/client/src/pages/* four tabs

apps/client/package.json:

{
  "name": "balance-agent-client",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "start": "vite preview"
  },
  "dependencies": {
    "@tanstack/react-query": "5.51.1",
    "axios": "1.7.2",
    "react": "18.2.0",
    "react-dom": "18.2.0"
  },
  "devDependencies": {
    "typescript": "5.4.5",
    "vite": "5.2.10"
  }
}

3a) Pages and UX

Use a simple top tab nav with 4 tabs:

Today

Shows one Agent Card fetched from /api/agent/card with timeOfDay inferred from client clock

Single form that captures:

Quick mood slider 0 to 10

Journal textarea

Quick gratitude input with 3 suggestion chips

One Save button that creates entries for what is filled

After save, show a micro success toast and updated streak

Journal

List of recent journal entries with date

New entry box with optional prompt from Agent Card

Gratitude

List of gratitude items and a streak counter

New quick-add input

Progress

7-day summary with numbers: journal count, gratitude count, average BalanceScore, streakDays

Badges grid with earned badges highlighted

A tiny sparkline for BalanceScore using native <svg>

Keep layouts minimal. Use CSS modules, focus on speed over fancy visuals.

3b) Client API helpers

useEntries(type) to query entries

useCreateEntry()

useCreateCheckin()

useWeeklySummary()

useAgentCard(timeOfDay)

3c) Env handling

Create apps/client/.env with VITE_API_BASE=http://localhost:5050 and use it in the Axios baseURL.

4) Root scripts to run both apps on Replit

At repository root, add a Procfile if Replit needs it, and set the run command to:

Install with pnpm install

Generate Prisma client and run migration

Start both dev servers concurrently

Example root README.md quickstart:

pnpm install
cd apps/server && pnpm prisma:gen && pnpm prisma:migrate
cd ../..
pnpm dev


On pnpm dev, server should run on port 5050, client on 5173. Enable CORS on server for http://localhost:5173.

5) Acceptance criteria for v0.1

Health check returns 200 at GET /api/health

Can create a JOURNAL entry and see it on Journal tab

Can create a GRATITUDE entry and see streak increment on Progress tab

Can create a CHECKIN and see BalanceScore on Progress summary

Agent Card returns a JSON object even without an API key, using a deterministic fallback

Badges grant correctly for FIRST_ENTRY and appear on Progress tab

Weekly summary endpoint returns counts and averages for the last 7 days

Data persists in SQLite between restarts

6) Minimal code stubs to generate

Create these stubs with working logic:

apps/server/src/lib/prisma.ts

import { PrismaClient } from "@prisma/client";
export const prisma = new PrismaClient();


apps/server/src/lib/scoring.ts

export function balanceScore(energy: number, rest: number, focus: number, connection: number) {
  const clamp = (x: number) => Math.max(0, Math.min(10, Math.round(x)));
  return clamp((energy + rest + focus + connection) / 4);
}


apps/server/src/services/agent.ts

import OpenAI from "openai";
import { config } from "dotenv";
config();

const apiKey = process.env.OPENAI_API_KEY;
const model = process.env.OPENAI_MODEL || "gpt-4o-mini";

export type AgentContext = {
  timeOfDay: "morning" | "midday" | "evening";
  lastMood?: number;
  lastGratitude?: string;
  lastEntrySnippet?: string;
};

export type AgentCard = {
  prompt: string;
  reflection: string;
  practice: string;
  category: "journal" | "gratitude" | "reset" | "wind_down";
};

const offlineCard: AgentCard = {
  prompt: "Write one line about what you want from today.",
  reflection: "You are doing your best with what you have.",
  practice: "Take 3 slow breaths and unclench your jaw.",
  category: "reset"
};

export async function getAgentCard(ctx: AgentContext): Promise<AgentCard> {
  if (!apiKey) return offlineCard;
  const client = new OpenAI({ apiKey });
  const sys =
    "You are a gentle life-balance coach. Speak concisely. Return JSON with keys prompt, reflection, practice, category. Categories: journal, gratitude, reset, wind_down. Keep it short and practical. Avoid medical or therapy claims.";
  const user = `timeOfDay=${ctx.timeOfDay}; lastMood=${ctx.lastMood ?? "n/a"}; lastGratitude=${ctx.lastGratitude ?? "n/a"}; lastEntry="${(ctx.lastEntrySnippet ?? "").slice(0, 160)}"`;
  const res = await client.chat.completions.create({
    model,
    messages: [
      { role: "system", content: sys },
      { role: "user", content: user }
    ],
    response_format: { type: "json_object" },
    temperature: 0.4,
    max_tokens: 200
  });
  try {
    const text = res.choices[0]?.message?.content ?? "";
    const obj = JSON.parse(text);
    return {
      prompt: obj.prompt ?? offlineCard.prompt,
      reflection: obj.reflection ?? offlineCard.reflection,
      practice: obj.practice ?? offlineCard.practice,
      category: obj.category ?? offlineCard.category
    };
  } catch {
    return offlineCard;
  }
}


apps/server/src/index.ts

import "dotenv/config";
import express from "express";
import cors from "cors";
import { prisma } from "./lib/prisma.js";
import { balanceScore } from "./lib/scoring.js";
import { getAgentCard } from "./services/agent.js";

const app = express();
app.use(cors({ origin: ["http://localhost:5173"], credentials: true }));
app.use(express.json());

const DEMO_USER_ID = "demo-user";

app.get("/api/health", (_, res) => res.json({ ok: true }));

app.post("/api/entries", async (req, res) => {
  const { type, content, meta } = req.body ?? {};
  if (!type || !content) return res.status(400).json({ error: "type and content required" });
  await ensureDemoUser();
  const entry = await prisma.entry.create({
    data: { userId: DEMO_USER_ID, type, content, meta }
  });
  await maybeGrantFirstEntry();
  res.json(entry);
});

app.get("/api/entries", async (req, res) => {
  const { type, limit } = req.query as any;
  await ensureDemoUser();
  const where = { userId: DEMO_USER_ID, ...(type ? { type } : {}) };
  const entries = await prisma.entry.findMany({
    where,
    orderBy: { createdAt: "desc" },
    take: limit ? Number(limit) : 50
  });
  res.json(entries);
});

app.post("/api/checkins", async (req, res) => {
  const { energy, rest, focus, connection, note } = req.body ?? {};
  await ensureDemoUser();
  const check = await prisma.checkin.create({
    data: { userId: DEMO_USER_ID, energy, rest, focus, connection, note }
  });
  const score = balanceScore(energy, rest, focus, connection);
  await prisma.entry.create({
    data: {
      userId: DEMO_USER_ID,
      type: "CHECKIN",
      content: note ?? "",
      meta: { score, energy, rest, focus, connection }
    }
  });
  await maybeGrantFirstEntry();
  res.json({ check, score });
});

app.get("/api/summary/weekly", async (_req, res) => {
  await ensureDemoUser();
  const since = new Date(Date.now() - 7 * 86400 * 1000);
  const entries = await prisma.entry.findMany({
    where: { userId: DEMO_USER_ID, createdAt: { gte: since } }
  });
  const journal = entries.filter(e => e.type === "JOURNAL").length;
  const gratitude = entries.filter(e => e.type === "GRATITUDE").length;
  const scores = entries
    .filter(e => e.type === "CHECKIN" && e.meta && (e.meta as any).score !== undefined)
    .map(e => (e.meta as any).score as number);
  const avgScore = scores.length ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length) : null;
  const streakDays = await computeStreakDays();
  const badges = await prisma.badge.findMany({ where: { userId: DEMO_USER_ID } });
  res.json({ journal, gratitude, avgScore, streakDays, badges });
});

app.post("/api/agent/card", async (req, res) => {
  const { timeOfDay, lastMood, lastGratitude, lastEntrySnippet } = req.body ?? {};
  const card = await getAgentCard({ timeOfDay, lastMood, lastGratitude, lastEntrySnippet });
  res.json(card);
});

app.get("/api/gamification", async (_req, res) => {
  await ensureDemoUser();
  const streakDays = await computeStreakDays();
  const badges = await prisma.badge.findMany({ where: { userId: DEMO_USER_ID } });
  res.json({ streakDays, badges });
});

const port = Number(process.env.PORT || 5050);
app.listen(port, () => console.log(`Server listening on ${port}`));

async function ensureDemoUser() {
  const u = await prisma.user.findUnique({ where: { id: DEMO_USER_ID } });
  if (!u) await prisma.user.create({ data: { id: DEMO_USER_ID, displayName: "Demo" } });
}

async function maybeGrantFirstEntry() {
  const count = await prisma.entry.count({ where: { userId: DEMO_USER_ID } });
  if (count === 1) {
    await prisma.badge.create({ data: { userId: DEMO_USER_ID, code: "FIRST_ENTRY" } });
  }
}

async function computeStreakDays(): Promise<number> {
  const entries = await prisma.entry.findMany({
    where: { userId: DEMO_USER_ID },
    orderBy: { createdAt: "desc" },
    select: { createdAt: true }
  });
  if (!entries.length) return 0;
  let streak = 0;
  const today = new Date();
  const daysSet = new Set(entries.map(e => e.createdAt.toISOString().slice(0, 10)));
  // Count back from today
  for (let i = 0; ; i++) {
    const d = new Date(today.getTime() - i * 86400 * 1000).toISOString().slice(0, 10);
    if (daysSet.has(d)) streak += 1;
    else break;
  }
  // Grant 7-day badge if needed
  if (streak >= 7) {
    const has = await prisma.badge.findFirst({ where: { userId: DEMO_USER_ID, code: "WEEK_STREAK_7" } });
    if (!has) await prisma.badge.create({ data: { userId: DEMO_USER_ID, code: "WEEK_STREAK_7" } });
  }
  // Gratitude 30 badge
  const gCount = await prisma.entry.count({ where: { userId: DEMO_USER_ID, type: "GRATITUDE" } });
  if (gCount >= 30) {
    const has = await prisma.badge.findFirst({ where: { userId: DEMO_USER_ID, code: "GRATITUDE_30" } });
    if (!has) await prisma.badge.create({ data: { userId: DEMO_USER_ID, code: "GRATITUDE_30" } });
  }
  return streak;
}

6b) Minimal client screens

Implement React pages with a top nav and four tabs. Use React Query to call the endpoints above. Include:

Today page that fetches one Agent Card on mount with inferred timeOfDay from local time

Forms to create entries and checkins

Progress page that calls /api/summary/weekly and /api/gamification

7) Quickstart on Replit

Create the repo structure as above.

Run pnpm install at root.

In apps/server, run pnpm prisma:gen then pnpm prisma:migrate.

Add .env with OPENAI_API_KEY if available, otherwise the agent will use offline fallback.

Run pnpm dev at the root. Client on 5173, server on 5050.

Open the client and verify:

Create a gratitude entry on Today tab.

Submit a check-in with 4 sliders.

See updated streak and summary on Progress tab.

Agent Card shows JSON-driven prompt and practice.

8) Stretch goals to leave as TODOs in comments

Email magic-link auth with passwordless provider or custom token endpoint

Local export to JSON

Weekly auto-report generation and storage in WeeklyReport

Optional offline cache with IndexedDB on client

Add a small practices library and mark completions for extra XP on the Progress tab

Please generate the entire code scaffold and working MVP based on the instructions above, including Prisma schema, Express routes, React pages, and minimal CSS.